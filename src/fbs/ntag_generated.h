// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_NTAG_OWW_NTAG_H_
#define FLATBUFFERS_GENERATED_NTAG_OWW_NTAG_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "common.h"

namespace oww {
namespace ntag {

struct TagUid;

struct KeyBytes;

enum class Key : int8_t {
  Application = 0,
  Terminal = 1,
  Authorization = 2,
  Reserved1 = 3,
  Reserved2 = 4,
  MIN = Application,
  MAX = Reserved2
};

inline const Key (&EnumValuesKey())[5] {
  static const Key values[] = {
    Key::Application,
    Key::Terminal,
    Key::Authorization,
    Key::Reserved1,
    Key::Reserved2
  };
  return values;
}

inline const char * const *EnumNamesKey() {
  static const char * const names[6] = {
    "Application",
    "Terminal",
    "Authorization",
    "Reserved1",
    "Reserved2",
    nullptr
  };
  return names;
}

inline const char *EnumNameKey(Key e) {
  if (::flatbuffers::IsOutRange(e, Key::Application, Key::Reserved2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesKey()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) TagUid FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t uid_[7];

 public:
  struct Traits;
  TagUid()
      : uid_() {
  }
  TagUid(::flatbuffers::span<const uint8_t, 7> _uid) {
    ::flatbuffers::CastToArray(uid_).CopyFromSpan(_uid);
  }
  const ::flatbuffers::Array<uint8_t, 7> *uid() const {
    return &::flatbuffers::CastToArray(uid_);
  }
};
FLATBUFFERS_STRUCT_END(TagUid, 7);

struct TagUid::Traits {
  using type = TagUid;
};

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) KeyBytes FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t uid_[16];

 public:
  struct Traits;
  KeyBytes()
      : uid_() {
  }
  KeyBytes(::flatbuffers::span<const uint8_t, 16> _uid) {
    ::flatbuffers::CastToArray(uid_).CopyFromSpan(_uid);
  }
  const ::flatbuffers::Array<uint8_t, 16> *uid() const {
    return &::flatbuffers::CastToArray(uid_);
  }
};
FLATBUFFERS_STRUCT_END(KeyBytes, 16);

struct KeyBytes::Traits {
  using type = KeyBytes;
};

}  // namespace ntag
}  // namespace oww

#endif  // FLATBUFFERS_GENERATED_NTAG_OWW_NTAG_H_
