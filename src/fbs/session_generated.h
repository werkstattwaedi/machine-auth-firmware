// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SESSION_OWW_SESSION_H_
#define FLATBUFFERS_GENERATED_SESSION_OWW_SESSION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "ntag_generated.h"

#include "common.h"

namespace oww {
namespace session {

struct FirstAuthentication;
struct FirstAuthenticationBuilder;
struct FirstAuthenticationT;

struct RecentAuthentication;
struct RecentAuthenticationBuilder;
struct RecentAuthenticationT;

struct AuthenticationPart2;
struct AuthenticationPart2Builder;
struct AuthenticationPart2T;

struct StateAuthorized;
struct StateAuthorizedBuilder;
struct StateAuthorizedT;

struct StateRejected;
struct StateRejectedBuilder;
struct StateRejectedT;

struct StartSessionRequest;
struct StartSessionRequestBuilder;
struct StartSessionRequestT;

struct StartSessionResponse;
struct StartSessionResponseBuilder;
struct StartSessionResponseT;

struct AuthenticatePart2Request;
struct AuthenticatePart2RequestBuilder;
struct AuthenticatePart2RequestT;

struct AuthenticatePart2Response;
struct AuthenticatePart2ResponseBuilder;
struct AuthenticatePart2ResponseT;

enum class Authentication : uint8_t {
  NONE = 0,
  FirstAuthentication = 1,
  RecentAuthentication = 2,
  MIN = NONE,
  MAX = RecentAuthentication
};

inline const Authentication (&EnumValuesAuthentication())[3] {
  static const Authentication values[] = {
    Authentication::NONE,
    Authentication::FirstAuthentication,
    Authentication::RecentAuthentication
  };
  return values;
}

inline const char * const *EnumNamesAuthentication() {
  static const char * const names[4] = {
    "NONE",
    "FirstAuthentication",
    "RecentAuthentication",
    nullptr
  };
  return names;
}

inline const char *EnumNameAuthentication(Authentication e) {
  if (::flatbuffers::IsOutRange(e, Authentication::NONE, Authentication::RecentAuthentication)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAuthentication()[index];
}

template<typename T> struct AuthenticationTraits {
  static const Authentication enum_value = Authentication::NONE;
};

template<> struct AuthenticationTraits<oww::session::FirstAuthentication> {
  static const Authentication enum_value = Authentication::FirstAuthentication;
};

template<> struct AuthenticationTraits<oww::session::RecentAuthentication> {
  static const Authentication enum_value = Authentication::RecentAuthentication;
};

template<typename T> struct AuthenticationUnionTraits {
  static const Authentication enum_value = Authentication::NONE;
};

template<> struct AuthenticationUnionTraits<oww::session::FirstAuthenticationT> {
  static const Authentication enum_value = Authentication::FirstAuthentication;
};

template<> struct AuthenticationUnionTraits<oww::session::RecentAuthenticationT> {
  static const Authentication enum_value = Authentication::RecentAuthentication;
};

struct AuthenticationUnion {
  Authentication type;
  void *value;

  AuthenticationUnion() : type(Authentication::NONE), value(nullptr) {}
  AuthenticationUnion(AuthenticationUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Authentication::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  AuthenticationUnion(const AuthenticationUnion &);
  AuthenticationUnion &operator=(const AuthenticationUnion &u)
    { AuthenticationUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  AuthenticationUnion &operator=(AuthenticationUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~AuthenticationUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = AuthenticationUnionTraits<RT>::enum_value;
    if (type != Authentication::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Authentication type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  oww::session::FirstAuthenticationT *AsFirstAuthentication() {
    return type == Authentication::FirstAuthentication ?
      reinterpret_cast<oww::session::FirstAuthenticationT *>(value) : nullptr;
  }
  const oww::session::FirstAuthenticationT *AsFirstAuthentication() const {
    return type == Authentication::FirstAuthentication ?
      reinterpret_cast<const oww::session::FirstAuthenticationT *>(value) : nullptr;
  }
  oww::session::RecentAuthenticationT *AsRecentAuthentication() {
    return type == Authentication::RecentAuthentication ?
      reinterpret_cast<oww::session::RecentAuthenticationT *>(value) : nullptr;
  }
  const oww::session::RecentAuthenticationT *AsRecentAuthentication() const {
    return type == Authentication::RecentAuthentication ?
      reinterpret_cast<const oww::session::RecentAuthenticationT *>(value) : nullptr;
  }
};

bool VerifyAuthentication(::flatbuffers::Verifier &verifier, const void *obj, Authentication type);
bool VerifyAuthenticationVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Authentication> *types);

enum class AuthorizationResult : uint8_t {
  NONE = 0,
  AuthenticationPart2 = 1,
  StateAuthorized = 2,
  StateRejected = 3,
  MIN = NONE,
  MAX = StateRejected
};

inline const AuthorizationResult (&EnumValuesAuthorizationResult())[4] {
  static const AuthorizationResult values[] = {
    AuthorizationResult::NONE,
    AuthorizationResult::AuthenticationPart2,
    AuthorizationResult::StateAuthorized,
    AuthorizationResult::StateRejected
  };
  return values;
}

inline const char * const *EnumNamesAuthorizationResult() {
  static const char * const names[5] = {
    "NONE",
    "AuthenticationPart2",
    "StateAuthorized",
    "StateRejected",
    nullptr
  };
  return names;
}

inline const char *EnumNameAuthorizationResult(AuthorizationResult e) {
  if (::flatbuffers::IsOutRange(e, AuthorizationResult::NONE, AuthorizationResult::StateRejected)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAuthorizationResult()[index];
}

template<typename T> struct AuthorizationResultTraits {
  static const AuthorizationResult enum_value = AuthorizationResult::NONE;
};

template<> struct AuthorizationResultTraits<oww::session::AuthenticationPart2> {
  static const AuthorizationResult enum_value = AuthorizationResult::AuthenticationPart2;
};

template<> struct AuthorizationResultTraits<oww::session::StateAuthorized> {
  static const AuthorizationResult enum_value = AuthorizationResult::StateAuthorized;
};

template<> struct AuthorizationResultTraits<oww::session::StateRejected> {
  static const AuthorizationResult enum_value = AuthorizationResult::StateRejected;
};

template<typename T> struct AuthorizationResultUnionTraits {
  static const AuthorizationResult enum_value = AuthorizationResult::NONE;
};

template<> struct AuthorizationResultUnionTraits<oww::session::AuthenticationPart2T> {
  static const AuthorizationResult enum_value = AuthorizationResult::AuthenticationPart2;
};

template<> struct AuthorizationResultUnionTraits<oww::session::StateAuthorizedT> {
  static const AuthorizationResult enum_value = AuthorizationResult::StateAuthorized;
};

template<> struct AuthorizationResultUnionTraits<oww::session::StateRejectedT> {
  static const AuthorizationResult enum_value = AuthorizationResult::StateRejected;
};

struct AuthorizationResultUnion {
  AuthorizationResult type;
  void *value;

  AuthorizationResultUnion() : type(AuthorizationResult::NONE), value(nullptr) {}
  AuthorizationResultUnion(AuthorizationResultUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(AuthorizationResult::NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  AuthorizationResultUnion(const AuthorizationResultUnion &);
  AuthorizationResultUnion &operator=(const AuthorizationResultUnion &u)
    { AuthorizationResultUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  AuthorizationResultUnion &operator=(AuthorizationResultUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~AuthorizationResultUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = AuthorizationResultUnionTraits<RT>::enum_value;
    if (type != AuthorizationResult::NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, AuthorizationResult type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  oww::session::AuthenticationPart2T *AsAuthenticationPart2() {
    return type == AuthorizationResult::AuthenticationPart2 ?
      reinterpret_cast<oww::session::AuthenticationPart2T *>(value) : nullptr;
  }
  const oww::session::AuthenticationPart2T *AsAuthenticationPart2() const {
    return type == AuthorizationResult::AuthenticationPart2 ?
      reinterpret_cast<const oww::session::AuthenticationPart2T *>(value) : nullptr;
  }
  oww::session::StateAuthorizedT *AsStateAuthorized() {
    return type == AuthorizationResult::StateAuthorized ?
      reinterpret_cast<oww::session::StateAuthorizedT *>(value) : nullptr;
  }
  const oww::session::StateAuthorizedT *AsStateAuthorized() const {
    return type == AuthorizationResult::StateAuthorized ?
      reinterpret_cast<const oww::session::StateAuthorizedT *>(value) : nullptr;
  }
  oww::session::StateRejectedT *AsStateRejected() {
    return type == AuthorizationResult::StateRejected ?
      reinterpret_cast<oww::session::StateRejectedT *>(value) : nullptr;
  }
  const oww::session::StateRejectedT *AsStateRejected() const {
    return type == AuthorizationResult::StateRejected ?
      reinterpret_cast<const oww::session::StateRejectedT *>(value) : nullptr;
  }
};

bool VerifyAuthorizationResult(::flatbuffers::Verifier &verifier, const void *obj, AuthorizationResult type);
bool VerifyAuthorizationResultVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AuthorizationResult> *types);

struct FirstAuthenticationT : public ::flatbuffers::NativeTable {
  typedef FirstAuthentication TableType;
  std::vector<uint8_t> ntag_challenge{};
};

struct FirstAuthentication FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef FirstAuthenticationT NativeTableType;
  typedef FirstAuthenticationBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NTAG_CHALLENGE = 4
  };
  const ::flatbuffers::Vector<uint8_t> *ntag_challenge() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_NTAG_CHALLENGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NTAG_CHALLENGE) &&
           verifier.VerifyVector(ntag_challenge()) &&
           verifier.EndTable();
  }
  FirstAuthenticationT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(FirstAuthenticationT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<FirstAuthentication> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FirstAuthenticationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct FirstAuthenticationBuilder {
  typedef FirstAuthentication Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ntag_challenge(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ntag_challenge) {
    fbb_.AddOffset(FirstAuthentication::VT_NTAG_CHALLENGE, ntag_challenge);
  }
  explicit FirstAuthenticationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<FirstAuthentication> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<FirstAuthentication>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<FirstAuthentication> CreateFirstAuthentication(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> ntag_challenge = 0) {
  FirstAuthenticationBuilder builder_(_fbb);
  builder_.add_ntag_challenge(ntag_challenge);
  return builder_.Finish();
}

struct FirstAuthentication::Traits {
  using type = FirstAuthentication;
  static auto constexpr Create = CreateFirstAuthentication;
};

inline ::flatbuffers::Offset<FirstAuthentication> CreateFirstAuthenticationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *ntag_challenge = nullptr) {
  auto ntag_challenge__ = ntag_challenge ? _fbb.CreateVector<uint8_t>(*ntag_challenge) : 0;
  return oww::session::CreateFirstAuthentication(
      _fbb,
      ntag_challenge__);
}

::flatbuffers::Offset<FirstAuthentication> CreateFirstAuthentication(::flatbuffers::FlatBufferBuilder &_fbb, const FirstAuthenticationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct RecentAuthenticationT : public ::flatbuffers::NativeTable {
  typedef RecentAuthentication TableType;
  particle::String token{};
};

struct RecentAuthentication FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef RecentAuthenticationT NativeTableType;
  typedef RecentAuthenticationBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKEN = 4
  };
  const ::flatbuffers::String *token() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TOKEN);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TOKEN) &&
           verifier.VerifyString(token()) &&
           verifier.EndTable();
  }
  RecentAuthenticationT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RecentAuthenticationT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<RecentAuthentication> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RecentAuthenticationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RecentAuthenticationBuilder {
  typedef RecentAuthentication Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_token(::flatbuffers::Offset<::flatbuffers::String> token) {
    fbb_.AddOffset(RecentAuthentication::VT_TOKEN, token);
  }
  explicit RecentAuthenticationBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<RecentAuthentication> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<RecentAuthentication>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<RecentAuthentication> CreateRecentAuthentication(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> token = 0) {
  RecentAuthenticationBuilder builder_(_fbb);
  builder_.add_token(token);
  return builder_.Finish();
}

struct RecentAuthentication::Traits {
  using type = RecentAuthentication;
  static auto constexpr Create = CreateRecentAuthentication;
};

inline ::flatbuffers::Offset<RecentAuthentication> CreateRecentAuthenticationDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *token = nullptr) {
  auto token__ = token ? _fbb.CreateString(token) : 0;
  return oww::session::CreateRecentAuthentication(
      _fbb,
      token__);
}

::flatbuffers::Offset<RecentAuthentication> CreateRecentAuthentication(::flatbuffers::FlatBufferBuilder &_fbb, const RecentAuthenticationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticationPart2T : public ::flatbuffers::NativeTable {
  typedef AuthenticationPart2 TableType;
  std::vector<uint8_t> cloud_challenge{};
};

struct AuthenticationPart2 FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AuthenticationPart2T NativeTableType;
  typedef AuthenticationPart2Builder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CLOUD_CHALLENGE = 4
  };
  const ::flatbuffers::Vector<uint8_t> *cloud_challenge() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_CLOUD_CHALLENGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CLOUD_CHALLENGE) &&
           verifier.VerifyVector(cloud_challenge()) &&
           verifier.EndTable();
  }
  AuthenticationPart2T *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthenticationPart2T *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AuthenticationPart2> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticationPart2T* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthenticationPart2Builder {
  typedef AuthenticationPart2 Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_cloud_challenge(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> cloud_challenge) {
    fbb_.AddOffset(AuthenticationPart2::VT_CLOUD_CHALLENGE, cloud_challenge);
  }
  explicit AuthenticationPart2Builder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AuthenticationPart2> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AuthenticationPart2>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AuthenticationPart2> CreateAuthenticationPart2(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> cloud_challenge = 0) {
  AuthenticationPart2Builder builder_(_fbb);
  builder_.add_cloud_challenge(cloud_challenge);
  return builder_.Finish();
}

struct AuthenticationPart2::Traits {
  using type = AuthenticationPart2;
  static auto constexpr Create = CreateAuthenticationPart2;
};

inline ::flatbuffers::Offset<AuthenticationPart2> CreateAuthenticationPart2Direct(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *cloud_challenge = nullptr) {
  auto cloud_challenge__ = cloud_challenge ? _fbb.CreateVector<uint8_t>(*cloud_challenge) : 0;
  return oww::session::CreateAuthenticationPart2(
      _fbb,
      cloud_challenge__);
}

::flatbuffers::Offset<AuthenticationPart2> CreateAuthenticationPart2(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticationPart2T *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StateAuthorizedT : public ::flatbuffers::NativeTable {
  typedef StateAuthorized TableType;
  particle::String name{};
};

struct StateAuthorized FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StateAuthorizedT NativeTableType;
  typedef StateAuthorizedBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
  StateAuthorizedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateAuthorizedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StateAuthorized> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateAuthorizedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateAuthorizedBuilder {
  typedef StateAuthorized Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(StateAuthorized::VT_NAME, name);
  }
  explicit StateAuthorizedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StateAuthorized> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StateAuthorized>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StateAuthorized> CreateStateAuthorized(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0) {
  StateAuthorizedBuilder builder_(_fbb);
  builder_.add_name(name);
  return builder_.Finish();
}

struct StateAuthorized::Traits {
  using type = StateAuthorized;
  static auto constexpr Create = CreateStateAuthorized;
};

inline ::flatbuffers::Offset<StateAuthorized> CreateStateAuthorizedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return oww::session::CreateStateAuthorized(
      _fbb,
      name__);
}

::flatbuffers::Offset<StateAuthorized> CreateStateAuthorized(::flatbuffers::FlatBufferBuilder &_fbb, const StateAuthorizedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StateRejectedT : public ::flatbuffers::NativeTable {
  typedef StateRejected TableType;
  particle::String message{};
};

struct StateRejected FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StateRejectedT NativeTableType;
  typedef StateRejectedBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MESSAGE = 4
  };
  const ::flatbuffers::String *message() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
  StateRejectedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StateRejectedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StateRejected> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateRejectedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StateRejectedBuilder {
  typedef StateRejected Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_message(::flatbuffers::Offset<::flatbuffers::String> message) {
    fbb_.AddOffset(StateRejected::VT_MESSAGE, message);
  }
  explicit StateRejectedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StateRejected> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StateRejected>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StateRejected> CreateStateRejected(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> message = 0) {
  StateRejectedBuilder builder_(_fbb);
  builder_.add_message(message);
  return builder_.Finish();
}

struct StateRejected::Traits {
  using type = StateRejected;
  static auto constexpr Create = CreateStateRejected;
};

inline ::flatbuffers::Offset<StateRejected> CreateStateRejectedDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return oww::session::CreateStateRejected(
      _fbb,
      message__);
}

::flatbuffers::Offset<StateRejected> CreateStateRejected(::flatbuffers::FlatBufferBuilder &_fbb, const StateRejectedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StartSessionRequestT : public ::flatbuffers::NativeTable {
  typedef StartSessionRequest TableType;
  std::unique_ptr<oww::ntag::TagUid> token_id{};
  particle::String machine_id{};
  oww::session::AuthenticationUnion authentication{};
  StartSessionRequestT() = default;
  StartSessionRequestT(const StartSessionRequestT &o);
  StartSessionRequestT(StartSessionRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  StartSessionRequestT &operator=(StartSessionRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct StartSessionRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartSessionRequestT NativeTableType;
  typedef StartSessionRequestBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKEN_ID = 4,
    VT_MACHINE_ID = 6,
    VT_AUTHENTICATION_TYPE = 8,
    VT_AUTHENTICATION = 10
  };
  const oww::ntag::TagUid *token_id() const {
    return GetStruct<const oww::ntag::TagUid *>(VT_TOKEN_ID);
  }
  const ::flatbuffers::String *machine_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_MACHINE_ID);
  }
  oww::session::Authentication authentication_type() const {
    return static_cast<oww::session::Authentication>(GetField<uint8_t>(VT_AUTHENTICATION_TYPE, 0));
  }
  const void *authentication() const {
    return GetPointer<const void *>(VT_AUTHENTICATION);
  }
  template<typename T> const T *authentication_as() const;
  const oww::session::FirstAuthentication *authentication_as_FirstAuthentication() const {
    return authentication_type() == oww::session::Authentication::FirstAuthentication ? static_cast<const oww::session::FirstAuthentication *>(authentication()) : nullptr;
  }
  const oww::session::RecentAuthentication *authentication_as_RecentAuthentication() const {
    return authentication_type() == oww::session::Authentication::RecentAuthentication ? static_cast<const oww::session::RecentAuthentication *>(authentication()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<oww::ntag::TagUid>(verifier, VT_TOKEN_ID, 4) &&
           VerifyOffset(verifier, VT_MACHINE_ID) &&
           verifier.VerifyString(machine_id()) &&
           VerifyField<uint8_t>(verifier, VT_AUTHENTICATION_TYPE, 1) &&
           VerifyOffset(verifier, VT_AUTHENTICATION) &&
           VerifyAuthentication(verifier, authentication(), authentication_type()) &&
           verifier.EndTable();
  }
  StartSessionRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StartSessionRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StartSessionRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const oww::session::FirstAuthentication *StartSessionRequest::authentication_as<oww::session::FirstAuthentication>() const {
  return authentication_as_FirstAuthentication();
}

template<> inline const oww::session::RecentAuthentication *StartSessionRequest::authentication_as<oww::session::RecentAuthentication>() const {
  return authentication_as_RecentAuthentication();
}

struct StartSessionRequestBuilder {
  typedef StartSessionRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_token_id(const oww::ntag::TagUid *token_id) {
    fbb_.AddStruct(StartSessionRequest::VT_TOKEN_ID, token_id);
  }
  void add_machine_id(::flatbuffers::Offset<::flatbuffers::String> machine_id) {
    fbb_.AddOffset(StartSessionRequest::VT_MACHINE_ID, machine_id);
  }
  void add_authentication_type(oww::session::Authentication authentication_type) {
    fbb_.AddElement<uint8_t>(StartSessionRequest::VT_AUTHENTICATION_TYPE, static_cast<uint8_t>(authentication_type), 0);
  }
  void add_authentication(::flatbuffers::Offset<void> authentication) {
    fbb_.AddOffset(StartSessionRequest::VT_AUTHENTICATION, authentication);
  }
  explicit StartSessionRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartSessionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartSessionRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StartSessionRequest> CreateStartSessionRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const oww::ntag::TagUid *token_id = nullptr,
    ::flatbuffers::Offset<::flatbuffers::String> machine_id = 0,
    oww::session::Authentication authentication_type = oww::session::Authentication::NONE,
    ::flatbuffers::Offset<void> authentication = 0) {
  StartSessionRequestBuilder builder_(_fbb);
  builder_.add_authentication(authentication);
  builder_.add_machine_id(machine_id);
  builder_.add_token_id(token_id);
  builder_.add_authentication_type(authentication_type);
  return builder_.Finish();
}

struct StartSessionRequest::Traits {
  using type = StartSessionRequest;
  static auto constexpr Create = CreateStartSessionRequest;
};

inline ::flatbuffers::Offset<StartSessionRequest> CreateStartSessionRequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const oww::ntag::TagUid *token_id = nullptr,
    const char *machine_id = nullptr,
    oww::session::Authentication authentication_type = oww::session::Authentication::NONE,
    ::flatbuffers::Offset<void> authentication = 0) {
  auto machine_id__ = machine_id ? _fbb.CreateString(machine_id) : 0;
  return oww::session::CreateStartSessionRequest(
      _fbb,
      token_id,
      machine_id__,
      authentication_type,
      authentication);
}

::flatbuffers::Offset<StartSessionRequest> CreateStartSessionRequest(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StartSessionResponseT : public ::flatbuffers::NativeTable {
  typedef StartSessionResponse TableType;
  particle::String session_id{};
  oww::session::AuthorizationResultUnion result{};
};

struct StartSessionResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef StartSessionResponseT NativeTableType;
  typedef StartSessionResponseBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_ID = 4,
    VT_RESULT_TYPE = 6,
    VT_RESULT = 8
  };
  const ::flatbuffers::String *session_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_ID);
  }
  oww::session::AuthorizationResult result_type() const {
    return static_cast<oww::session::AuthorizationResult>(GetField<uint8_t>(VT_RESULT_TYPE, 0));
  }
  const void *result() const {
    return GetPointer<const void *>(VT_RESULT);
  }
  template<typename T> const T *result_as() const;
  const oww::session::AuthenticationPart2 *result_as_AuthenticationPart2() const {
    return result_type() == oww::session::AuthorizationResult::AuthenticationPart2 ? static_cast<const oww::session::AuthenticationPart2 *>(result()) : nullptr;
  }
  const oww::session::StateAuthorized *result_as_StateAuthorized() const {
    return result_type() == oww::session::AuthorizationResult::StateAuthorized ? static_cast<const oww::session::StateAuthorized *>(result()) : nullptr;
  }
  const oww::session::StateRejected *result_as_StateRejected() const {
    return result_type() == oww::session::AuthorizationResult::StateRejected ? static_cast<const oww::session::StateRejected *>(result()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSION_ID) &&
           verifier.VerifyString(session_id()) &&
           VerifyField<uint8_t>(verifier, VT_RESULT_TYPE, 1) &&
           VerifyOffset(verifier, VT_RESULT) &&
           VerifyAuthorizationResult(verifier, result(), result_type()) &&
           verifier.EndTable();
  }
  StartSessionResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StartSessionResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<StartSessionResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const oww::session::AuthenticationPart2 *StartSessionResponse::result_as<oww::session::AuthenticationPart2>() const {
  return result_as_AuthenticationPart2();
}

template<> inline const oww::session::StateAuthorized *StartSessionResponse::result_as<oww::session::StateAuthorized>() const {
  return result_as_StateAuthorized();
}

template<> inline const oww::session::StateRejected *StartSessionResponse::result_as<oww::session::StateRejected>() const {
  return result_as_StateRejected();
}

struct StartSessionResponseBuilder {
  typedef StartSessionResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session_id(::flatbuffers::Offset<::flatbuffers::String> session_id) {
    fbb_.AddOffset(StartSessionResponse::VT_SESSION_ID, session_id);
  }
  void add_result_type(oww::session::AuthorizationResult result_type) {
    fbb_.AddElement<uint8_t>(StartSessionResponse::VT_RESULT_TYPE, static_cast<uint8_t>(result_type), 0);
  }
  void add_result(::flatbuffers::Offset<void> result) {
    fbb_.AddOffset(StartSessionResponse::VT_RESULT, result);
  }
  explicit StartSessionResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<StartSessionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<StartSessionResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<StartSessionResponse> CreateStartSessionResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> session_id = 0,
    oww::session::AuthorizationResult result_type = oww::session::AuthorizationResult::NONE,
    ::flatbuffers::Offset<void> result = 0) {
  StartSessionResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_session_id(session_id);
  builder_.add_result_type(result_type);
  return builder_.Finish();
}

struct StartSessionResponse::Traits {
  using type = StartSessionResponse;
  static auto constexpr Create = CreateStartSessionResponse;
};

inline ::flatbuffers::Offset<StartSessionResponse> CreateStartSessionResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *session_id = nullptr,
    oww::session::AuthorizationResult result_type = oww::session::AuthorizationResult::NONE,
    ::flatbuffers::Offset<void> result = 0) {
  auto session_id__ = session_id ? _fbb.CreateString(session_id) : 0;
  return oww::session::CreateStartSessionResponse(
      _fbb,
      session_id__,
      result_type,
      result);
}

::flatbuffers::Offset<StartSessionResponse> CreateStartSessionResponse(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticatePart2RequestT : public ::flatbuffers::NativeTable {
  typedef AuthenticatePart2Request TableType;
  particle::String session_id{};
  std::vector<uint8_t> encrypted_ntag_response{};
};

struct AuthenticatePart2Request FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AuthenticatePart2RequestT NativeTableType;
  typedef AuthenticatePart2RequestBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_ID = 4,
    VT_ENCRYPTED_NTAG_RESPONSE = 6
  };
  const ::flatbuffers::String *session_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_ID);
  }
  const ::flatbuffers::Vector<uint8_t> *encrypted_ntag_response() const {
    return GetPointer<const ::flatbuffers::Vector<uint8_t> *>(VT_ENCRYPTED_NTAG_RESPONSE);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSION_ID) &&
           verifier.VerifyString(session_id()) &&
           VerifyOffset(verifier, VT_ENCRYPTED_NTAG_RESPONSE) &&
           verifier.VerifyVector(encrypted_ntag_response()) &&
           verifier.EndTable();
  }
  AuthenticatePart2RequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthenticatePart2RequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AuthenticatePart2Request> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatePart2RequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct AuthenticatePart2RequestBuilder {
  typedef AuthenticatePart2Request Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session_id(::flatbuffers::Offset<::flatbuffers::String> session_id) {
    fbb_.AddOffset(AuthenticatePart2Request::VT_SESSION_ID, session_id);
  }
  void add_encrypted_ntag_response(::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> encrypted_ntag_response) {
    fbb_.AddOffset(AuthenticatePart2Request::VT_ENCRYPTED_NTAG_RESPONSE, encrypted_ntag_response);
  }
  explicit AuthenticatePart2RequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AuthenticatePart2Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AuthenticatePart2Request>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AuthenticatePart2Request> CreateAuthenticatePart2Request(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> session_id = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint8_t>> encrypted_ntag_response = 0) {
  AuthenticatePart2RequestBuilder builder_(_fbb);
  builder_.add_encrypted_ntag_response(encrypted_ntag_response);
  builder_.add_session_id(session_id);
  return builder_.Finish();
}

struct AuthenticatePart2Request::Traits {
  using type = AuthenticatePart2Request;
  static auto constexpr Create = CreateAuthenticatePart2Request;
};

inline ::flatbuffers::Offset<AuthenticatePart2Request> CreateAuthenticatePart2RequestDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *session_id = nullptr,
    const std::vector<uint8_t> *encrypted_ntag_response = nullptr) {
  auto session_id__ = session_id ? _fbb.CreateString(session_id) : 0;
  auto encrypted_ntag_response__ = encrypted_ntag_response ? _fbb.CreateVector<uint8_t>(*encrypted_ntag_response) : 0;
  return oww::session::CreateAuthenticatePart2Request(
      _fbb,
      session_id__,
      encrypted_ntag_response__);
}

::flatbuffers::Offset<AuthenticatePart2Request> CreateAuthenticatePart2Request(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatePart2RequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct AuthenticatePart2ResponseT : public ::flatbuffers::NativeTable {
  typedef AuthenticatePart2Response TableType;
  particle::String session_id{};
  oww::session::AuthorizationResultUnion result{};
};

struct AuthenticatePart2Response FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef AuthenticatePart2ResponseT NativeTableType;
  typedef AuthenticatePart2ResponseBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SESSION_ID = 4,
    VT_RESULT_TYPE = 6,
    VT_RESULT = 8
  };
  const ::flatbuffers::String *session_id() const {
    return GetPointer<const ::flatbuffers::String *>(VT_SESSION_ID);
  }
  oww::session::AuthorizationResult result_type() const {
    return static_cast<oww::session::AuthorizationResult>(GetField<uint8_t>(VT_RESULT_TYPE, 0));
  }
  const void *result() const {
    return GetPointer<const void *>(VT_RESULT);
  }
  template<typename T> const T *result_as() const;
  const oww::session::AuthenticationPart2 *result_as_AuthenticationPart2() const {
    return result_type() == oww::session::AuthorizationResult::AuthenticationPart2 ? static_cast<const oww::session::AuthenticationPart2 *>(result()) : nullptr;
  }
  const oww::session::StateAuthorized *result_as_StateAuthorized() const {
    return result_type() == oww::session::AuthorizationResult::StateAuthorized ? static_cast<const oww::session::StateAuthorized *>(result()) : nullptr;
  }
  const oww::session::StateRejected *result_as_StateRejected() const {
    return result_type() == oww::session::AuthorizationResult::StateRejected ? static_cast<const oww::session::StateRejected *>(result()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SESSION_ID) &&
           verifier.VerifyString(session_id()) &&
           VerifyField<uint8_t>(verifier, VT_RESULT_TYPE, 1) &&
           VerifyOffset(verifier, VT_RESULT) &&
           VerifyAuthorizationResult(verifier, result(), result_type()) &&
           verifier.EndTable();
  }
  AuthenticatePart2ResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(AuthenticatePart2ResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<AuthenticatePart2Response> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatePart2ResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const oww::session::AuthenticationPart2 *AuthenticatePart2Response::result_as<oww::session::AuthenticationPart2>() const {
  return result_as_AuthenticationPart2();
}

template<> inline const oww::session::StateAuthorized *AuthenticatePart2Response::result_as<oww::session::StateAuthorized>() const {
  return result_as_StateAuthorized();
}

template<> inline const oww::session::StateRejected *AuthenticatePart2Response::result_as<oww::session::StateRejected>() const {
  return result_as_StateRejected();
}

struct AuthenticatePart2ResponseBuilder {
  typedef AuthenticatePart2Response Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_session_id(::flatbuffers::Offset<::flatbuffers::String> session_id) {
    fbb_.AddOffset(AuthenticatePart2Response::VT_SESSION_ID, session_id);
  }
  void add_result_type(oww::session::AuthorizationResult result_type) {
    fbb_.AddElement<uint8_t>(AuthenticatePart2Response::VT_RESULT_TYPE, static_cast<uint8_t>(result_type), 0);
  }
  void add_result(::flatbuffers::Offset<void> result) {
    fbb_.AddOffset(AuthenticatePart2Response::VT_RESULT, result);
  }
  explicit AuthenticatePart2ResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<AuthenticatePart2Response> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<AuthenticatePart2Response>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<AuthenticatePart2Response> CreateAuthenticatePart2Response(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> session_id = 0,
    oww::session::AuthorizationResult result_type = oww::session::AuthorizationResult::NONE,
    ::flatbuffers::Offset<void> result = 0) {
  AuthenticatePart2ResponseBuilder builder_(_fbb);
  builder_.add_result(result);
  builder_.add_session_id(session_id);
  builder_.add_result_type(result_type);
  return builder_.Finish();
}

struct AuthenticatePart2Response::Traits {
  using type = AuthenticatePart2Response;
  static auto constexpr Create = CreateAuthenticatePart2Response;
};

inline ::flatbuffers::Offset<AuthenticatePart2Response> CreateAuthenticatePart2ResponseDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *session_id = nullptr,
    oww::session::AuthorizationResult result_type = oww::session::AuthorizationResult::NONE,
    ::flatbuffers::Offset<void> result = 0) {
  auto session_id__ = session_id ? _fbb.CreateString(session_id) : 0;
  return oww::session::CreateAuthenticatePart2Response(
      _fbb,
      session_id__,
      result_type,
      result);
}

::flatbuffers::Offset<AuthenticatePart2Response> CreateAuthenticatePart2Response(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatePart2ResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline FirstAuthenticationT *FirstAuthentication::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<FirstAuthenticationT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void FirstAuthentication::UnPackTo(FirstAuthenticationT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ntag_challenge(); if (_e) { _o->ntag_challenge.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->ntag_challenge.begin()); } }
}

inline ::flatbuffers::Offset<FirstAuthentication> FirstAuthentication::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const FirstAuthenticationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateFirstAuthentication(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<FirstAuthentication> CreateFirstAuthentication(::flatbuffers::FlatBufferBuilder &_fbb, const FirstAuthenticationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const FirstAuthenticationT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ntag_challenge = _o->ntag_challenge.size() ? _fbb.CreateVector(_o->ntag_challenge) : 0;
  return oww::session::CreateFirstAuthentication(
      _fbb,
      _ntag_challenge);
}

inline RecentAuthenticationT *RecentAuthentication::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<RecentAuthenticationT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RecentAuthentication::UnPackTo(RecentAuthenticationT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = token(); if (_e) _o->token = _e->str(); }
}

inline ::flatbuffers::Offset<RecentAuthentication> RecentAuthentication::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const RecentAuthenticationT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRecentAuthentication(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<RecentAuthentication> CreateRecentAuthentication(::flatbuffers::FlatBufferBuilder &_fbb, const RecentAuthenticationT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const RecentAuthenticationT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _token = _o->token.empty() ? 0 : _fbb.CreateString(_o->token);
  return oww::session::CreateRecentAuthentication(
      _fbb,
      _token);
}

inline AuthenticationPart2T *AuthenticationPart2::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AuthenticationPart2T>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AuthenticationPart2::UnPackTo(AuthenticationPart2T *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = cloud_challenge(); if (_e) { _o->cloud_challenge.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->cloud_challenge.begin()); } }
}

inline ::flatbuffers::Offset<AuthenticationPart2> AuthenticationPart2::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticationPart2T* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthenticationPart2(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AuthenticationPart2> CreateAuthenticationPart2(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticationPart2T *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AuthenticationPart2T* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _cloud_challenge = _o->cloud_challenge.size() ? _fbb.CreateVector(_o->cloud_challenge) : 0;
  return oww::session::CreateAuthenticationPart2(
      _fbb,
      _cloud_challenge);
}

inline StateAuthorizedT *StateAuthorized::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StateAuthorizedT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StateAuthorized::UnPackTo(StateAuthorizedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
}

inline ::flatbuffers::Offset<StateAuthorized> StateAuthorized::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateAuthorizedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStateAuthorized(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StateAuthorized> CreateStateAuthorized(::flatbuffers::FlatBufferBuilder &_fbb, const StateAuthorizedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StateAuthorizedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  return oww::session::CreateStateAuthorized(
      _fbb,
      _name);
}

inline StateRejectedT *StateRejected::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StateRejectedT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StateRejected::UnPackTo(StateRejectedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = message(); if (_e) _o->message = _e->str(); }
}

inline ::flatbuffers::Offset<StateRejected> StateRejected::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StateRejectedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStateRejected(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StateRejected> CreateStateRejected(::flatbuffers::FlatBufferBuilder &_fbb, const StateRejectedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StateRejectedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _message = _o->message.empty() ? 0 : _fbb.CreateString(_o->message);
  return oww::session::CreateStateRejected(
      _fbb,
      _message);
}

inline StartSessionRequestT::StartSessionRequestT(const StartSessionRequestT &o)
      : token_id((o.token_id) ? new oww::ntag::TagUid(*o.token_id) : nullptr),
        machine_id(o.machine_id),
        authentication(o.authentication) {
}

inline StartSessionRequestT &StartSessionRequestT::operator=(StartSessionRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(token_id, o.token_id);
  std::swap(machine_id, o.machine_id);
  std::swap(authentication, o.authentication);
  return *this;
}

inline StartSessionRequestT *StartSessionRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StartSessionRequestT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StartSessionRequest::UnPackTo(StartSessionRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = token_id(); if (_e) _o->token_id = std::unique_ptr<oww::ntag::TagUid>(new oww::ntag::TagUid(*_e)); }
  { auto _e = machine_id(); if (_e) _o->machine_id = _e->str(); }
  { auto _e = authentication_type(); _o->authentication.type = _e; }
  { auto _e = authentication(); if (_e) _o->authentication.value = oww::session::AuthenticationUnion::UnPack(_e, authentication_type(), _resolver); }
}

inline ::flatbuffers::Offset<StartSessionRequest> StartSessionRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStartSessionRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StartSessionRequest> CreateStartSessionRequest(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StartSessionRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _token_id = _o->token_id ? _o->token_id.get() : nullptr;
  auto _machine_id = _o->machine_id.empty() ? 0 : _fbb.CreateString(_o->machine_id);
  auto _authentication_type = _o->authentication.type;
  auto _authentication = _o->authentication.Pack(_fbb);
  return oww::session::CreateStartSessionRequest(
      _fbb,
      _token_id,
      _machine_id,
      _authentication_type,
      _authentication);
}

inline StartSessionResponseT *StartSessionResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<StartSessionResponseT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StartSessionResponse::UnPackTo(StartSessionResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = session_id(); if (_e) _o->session_id = _e->str(); }
  { auto _e = result_type(); _o->result.type = _e; }
  { auto _e = result(); if (_e) _o->result.value = oww::session::AuthorizationResultUnion::UnPack(_e, result_type(), _resolver); }
}

inline ::flatbuffers::Offset<StartSessionResponse> StartSessionResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStartSessionResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<StartSessionResponse> CreateStartSessionResponse(::flatbuffers::FlatBufferBuilder &_fbb, const StartSessionResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const StartSessionResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _session_id = _o->session_id.empty() ? 0 : _fbb.CreateString(_o->session_id);
  auto _result_type = _o->result.type;
  auto _result = _o->result.Pack(_fbb);
  return oww::session::CreateStartSessionResponse(
      _fbb,
      _session_id,
      _result_type,
      _result);
}

inline AuthenticatePart2RequestT *AuthenticatePart2Request::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AuthenticatePart2RequestT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AuthenticatePart2Request::UnPackTo(AuthenticatePart2RequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = session_id(); if (_e) _o->session_id = _e->str(); }
  { auto _e = encrypted_ntag_response(); if (_e) { _o->encrypted_ntag_response.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->encrypted_ntag_response.begin()); } }
}

inline ::flatbuffers::Offset<AuthenticatePart2Request> AuthenticatePart2Request::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatePart2RequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthenticatePart2Request(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AuthenticatePart2Request> CreateAuthenticatePart2Request(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatePart2RequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AuthenticatePart2RequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _session_id = _o->session_id.empty() ? 0 : _fbb.CreateString(_o->session_id);
  auto _encrypted_ntag_response = _o->encrypted_ntag_response.size() ? _fbb.CreateVector(_o->encrypted_ntag_response) : 0;
  return oww::session::CreateAuthenticatePart2Request(
      _fbb,
      _session_id,
      _encrypted_ntag_response);
}

inline AuthenticatePart2ResponseT *AuthenticatePart2Response::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<AuthenticatePart2ResponseT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void AuthenticatePart2Response::UnPackTo(AuthenticatePart2ResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = session_id(); if (_e) _o->session_id = _e->str(); }
  { auto _e = result_type(); _o->result.type = _e; }
  { auto _e = result(); if (_e) _o->result.value = oww::session::AuthorizationResultUnion::UnPack(_e, result_type(), _resolver); }
}

inline ::flatbuffers::Offset<AuthenticatePart2Response> AuthenticatePart2Response::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatePart2ResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateAuthenticatePart2Response(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<AuthenticatePart2Response> CreateAuthenticatePart2Response(::flatbuffers::FlatBufferBuilder &_fbb, const AuthenticatePart2ResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const AuthenticatePart2ResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _session_id = _o->session_id.empty() ? 0 : _fbb.CreateString(_o->session_id);
  auto _result_type = _o->result.type;
  auto _result = _o->result.Pack(_fbb);
  return oww::session::CreateAuthenticatePart2Response(
      _fbb,
      _session_id,
      _result_type,
      _result);
}

inline bool VerifyAuthentication(::flatbuffers::Verifier &verifier, const void *obj, Authentication type) {
  switch (type) {
    case Authentication::NONE: {
      return true;
    }
    case Authentication::FirstAuthentication: {
      auto ptr = reinterpret_cast<const oww::session::FirstAuthentication *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Authentication::RecentAuthentication: {
      auto ptr = reinterpret_cast<const oww::session::RecentAuthentication *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAuthenticationVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<Authentication> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAuthentication(
        verifier,  values->Get(i), types->GetEnum<Authentication>(i))) {
      return false;
    }
  }
  return true;
}

inline void *AuthenticationUnion::UnPack(const void *obj, Authentication type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Authentication::FirstAuthentication: {
      auto ptr = reinterpret_cast<const oww::session::FirstAuthentication *>(obj);
      return ptr->UnPack(resolver);
    }
    case Authentication::RecentAuthentication: {
      auto ptr = reinterpret_cast<const oww::session::RecentAuthentication *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> AuthenticationUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Authentication::FirstAuthentication: {
      auto ptr = reinterpret_cast<const oww::session::FirstAuthenticationT *>(value);
      return CreateFirstAuthentication(_fbb, ptr, _rehasher).Union();
    }
    case Authentication::RecentAuthentication: {
      auto ptr = reinterpret_cast<const oww::session::RecentAuthenticationT *>(value);
      return CreateRecentAuthentication(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline AuthenticationUnion::AuthenticationUnion(const AuthenticationUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Authentication::FirstAuthentication: {
      value = new oww::session::FirstAuthenticationT(*reinterpret_cast<oww::session::FirstAuthenticationT *>(u.value));
      break;
    }
    case Authentication::RecentAuthentication: {
      value = new oww::session::RecentAuthenticationT(*reinterpret_cast<oww::session::RecentAuthenticationT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void AuthenticationUnion::Reset() {
  switch (type) {
    case Authentication::FirstAuthentication: {
      auto ptr = reinterpret_cast<oww::session::FirstAuthenticationT *>(value);
      delete ptr;
      break;
    }
    case Authentication::RecentAuthentication: {
      auto ptr = reinterpret_cast<oww::session::RecentAuthenticationT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Authentication::NONE;
}

inline bool VerifyAuthorizationResult(::flatbuffers::Verifier &verifier, const void *obj, AuthorizationResult type) {
  switch (type) {
    case AuthorizationResult::NONE: {
      return true;
    }
    case AuthorizationResult::AuthenticationPart2: {
      auto ptr = reinterpret_cast<const oww::session::AuthenticationPart2 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AuthorizationResult::StateAuthorized: {
      auto ptr = reinterpret_cast<const oww::session::StateAuthorized *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AuthorizationResult::StateRejected: {
      auto ptr = reinterpret_cast<const oww::session::StateRejected *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyAuthorizationResultVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<AuthorizationResult> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAuthorizationResult(
        verifier,  values->Get(i), types->GetEnum<AuthorizationResult>(i))) {
      return false;
    }
  }
  return true;
}

inline void *AuthorizationResultUnion::UnPack(const void *obj, AuthorizationResult type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case AuthorizationResult::AuthenticationPart2: {
      auto ptr = reinterpret_cast<const oww::session::AuthenticationPart2 *>(obj);
      return ptr->UnPack(resolver);
    }
    case AuthorizationResult::StateAuthorized: {
      auto ptr = reinterpret_cast<const oww::session::StateAuthorized *>(obj);
      return ptr->UnPack(resolver);
    }
    case AuthorizationResult::StateRejected: {
      auto ptr = reinterpret_cast<const oww::session::StateRejected *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> AuthorizationResultUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case AuthorizationResult::AuthenticationPart2: {
      auto ptr = reinterpret_cast<const oww::session::AuthenticationPart2T *>(value);
      return CreateAuthenticationPart2(_fbb, ptr, _rehasher).Union();
    }
    case AuthorizationResult::StateAuthorized: {
      auto ptr = reinterpret_cast<const oww::session::StateAuthorizedT *>(value);
      return CreateStateAuthorized(_fbb, ptr, _rehasher).Union();
    }
    case AuthorizationResult::StateRejected: {
      auto ptr = reinterpret_cast<const oww::session::StateRejectedT *>(value);
      return CreateStateRejected(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline AuthorizationResultUnion::AuthorizationResultUnion(const AuthorizationResultUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case AuthorizationResult::AuthenticationPart2: {
      value = new oww::session::AuthenticationPart2T(*reinterpret_cast<oww::session::AuthenticationPart2T *>(u.value));
      break;
    }
    case AuthorizationResult::StateAuthorized: {
      value = new oww::session::StateAuthorizedT(*reinterpret_cast<oww::session::StateAuthorizedT *>(u.value));
      break;
    }
    case AuthorizationResult::StateRejected: {
      value = new oww::session::StateRejectedT(*reinterpret_cast<oww::session::StateRejectedT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void AuthorizationResultUnion::Reset() {
  switch (type) {
    case AuthorizationResult::AuthenticationPart2: {
      auto ptr = reinterpret_cast<oww::session::AuthenticationPart2T *>(value);
      delete ptr;
      break;
    }
    case AuthorizationResult::StateAuthorized: {
      auto ptr = reinterpret_cast<oww::session::StateAuthorizedT *>(value);
      delete ptr;
      break;
    }
    case AuthorizationResult::StateRejected: {
      auto ptr = reinterpret_cast<oww::session::StateRejectedT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = AuthorizationResult::NONE;
}

}  // namespace session
}  // namespace oww

#endif  // FLATBUFFERS_GENERATED_SESSION_OWW_SESSION_H_
