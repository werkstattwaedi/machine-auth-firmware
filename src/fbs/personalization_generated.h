// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PERSONALIZATION_OWW_PERSONALIZATION_H_
#define FLATBUFFERS_GENERATED_PERSONALIZATION_OWW_PERSONALIZATION_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 25 &&
              FLATBUFFERS_VERSION_MINOR == 2 &&
              FLATBUFFERS_VERSION_REVISION == 10,
             "Non-compatible flatbuffers version included");

#include "ntag_generated.h"

#include "common.h"

namespace oww {
namespace personalization {

struct KeyDiversificationRequest;
struct KeyDiversificationRequestBuilder;
struct KeyDiversificationRequestT;

struct KeyDiversificationResponse;
struct KeyDiversificationResponseBuilder;
struct KeyDiversificationResponseT;

struct KeyDiversificationRequestT : public ::flatbuffers::NativeTable {
  typedef KeyDiversificationRequest TableType;
  std::unique_ptr<oww::ntag::TagUid> token_id{};
  KeyDiversificationRequestT() = default;
  KeyDiversificationRequestT(const KeyDiversificationRequestT &o);
  KeyDiversificationRequestT(KeyDiversificationRequestT&&) FLATBUFFERS_NOEXCEPT = default;
  KeyDiversificationRequestT &operator=(KeyDiversificationRequestT o) FLATBUFFERS_NOEXCEPT;
};

struct KeyDiversificationRequest FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyDiversificationRequestT NativeTableType;
  typedef KeyDiversificationRequestBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOKEN_ID = 4
  };
  const oww::ntag::TagUid *token_id() const {
    return GetStruct<const oww::ntag::TagUid *>(VT_TOKEN_ID);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<oww::ntag::TagUid>(verifier, VT_TOKEN_ID, 1) &&
           verifier.EndTable();
  }
  KeyDiversificationRequestT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KeyDiversificationRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<KeyDiversificationRequest> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const KeyDiversificationRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KeyDiversificationRequestBuilder {
  typedef KeyDiversificationRequest Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_token_id(const oww::ntag::TagUid *token_id) {
    fbb_.AddStruct(KeyDiversificationRequest::VT_TOKEN_ID, token_id);
  }
  explicit KeyDiversificationRequestBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyDiversificationRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyDiversificationRequest>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyDiversificationRequest> CreateKeyDiversificationRequest(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const oww::ntag::TagUid *token_id = nullptr) {
  KeyDiversificationRequestBuilder builder_(_fbb);
  builder_.add_token_id(token_id);
  return builder_.Finish();
}

struct KeyDiversificationRequest::Traits {
  using type = KeyDiversificationRequest;
  static auto constexpr Create = CreateKeyDiversificationRequest;
};

::flatbuffers::Offset<KeyDiversificationRequest> CreateKeyDiversificationRequest(::flatbuffers::FlatBufferBuilder &_fbb, const KeyDiversificationRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct KeyDiversificationResponseT : public ::flatbuffers::NativeTable {
  typedef KeyDiversificationResponse TableType;
  std::unique_ptr<oww::ntag::KeyBytes> application_key{};
  std::unique_ptr<oww::ntag::KeyBytes> authorization_key{};
  std::unique_ptr<oww::ntag::KeyBytes> reserved1_key{};
  std::unique_ptr<oww::ntag::KeyBytes> reserved2_key{};
  KeyDiversificationResponseT() = default;
  KeyDiversificationResponseT(const KeyDiversificationResponseT &o);
  KeyDiversificationResponseT(KeyDiversificationResponseT&&) FLATBUFFERS_NOEXCEPT = default;
  KeyDiversificationResponseT &operator=(KeyDiversificationResponseT o) FLATBUFFERS_NOEXCEPT;
};

struct KeyDiversificationResponse FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef KeyDiversificationResponseT NativeTableType;
  typedef KeyDiversificationResponseBuilder Builder;
  struct Traits;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPLICATION_KEY = 4,
    VT_AUTHORIZATION_KEY = 6,
    VT_RESERVED1_KEY = 8,
    VT_RESERVED2_KEY = 10
  };
  const oww::ntag::KeyBytes *application_key() const {
    return GetStruct<const oww::ntag::KeyBytes *>(VT_APPLICATION_KEY);
  }
  const oww::ntag::KeyBytes *authorization_key() const {
    return GetStruct<const oww::ntag::KeyBytes *>(VT_AUTHORIZATION_KEY);
  }
  const oww::ntag::KeyBytes *reserved1_key() const {
    return GetStruct<const oww::ntag::KeyBytes *>(VT_RESERVED1_KEY);
  }
  const oww::ntag::KeyBytes *reserved2_key() const {
    return GetStruct<const oww::ntag::KeyBytes *>(VT_RESERVED2_KEY);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<oww::ntag::KeyBytes>(verifier, VT_APPLICATION_KEY, 1) &&
           VerifyField<oww::ntag::KeyBytes>(verifier, VT_AUTHORIZATION_KEY, 1) &&
           VerifyField<oww::ntag::KeyBytes>(verifier, VT_RESERVED1_KEY, 1) &&
           VerifyField<oww::ntag::KeyBytes>(verifier, VT_RESERVED2_KEY, 1) &&
           verifier.EndTable();
  }
  KeyDiversificationResponseT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(KeyDiversificationResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<KeyDiversificationResponse> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const KeyDiversificationResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct KeyDiversificationResponseBuilder {
  typedef KeyDiversificationResponse Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_application_key(const oww::ntag::KeyBytes *application_key) {
    fbb_.AddStruct(KeyDiversificationResponse::VT_APPLICATION_KEY, application_key);
  }
  void add_authorization_key(const oww::ntag::KeyBytes *authorization_key) {
    fbb_.AddStruct(KeyDiversificationResponse::VT_AUTHORIZATION_KEY, authorization_key);
  }
  void add_reserved1_key(const oww::ntag::KeyBytes *reserved1_key) {
    fbb_.AddStruct(KeyDiversificationResponse::VT_RESERVED1_KEY, reserved1_key);
  }
  void add_reserved2_key(const oww::ntag::KeyBytes *reserved2_key) {
    fbb_.AddStruct(KeyDiversificationResponse::VT_RESERVED2_KEY, reserved2_key);
  }
  explicit KeyDiversificationResponseBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<KeyDiversificationResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<KeyDiversificationResponse>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<KeyDiversificationResponse> CreateKeyDiversificationResponse(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const oww::ntag::KeyBytes *application_key = nullptr,
    const oww::ntag::KeyBytes *authorization_key = nullptr,
    const oww::ntag::KeyBytes *reserved1_key = nullptr,
    const oww::ntag::KeyBytes *reserved2_key = nullptr) {
  KeyDiversificationResponseBuilder builder_(_fbb);
  builder_.add_reserved2_key(reserved2_key);
  builder_.add_reserved1_key(reserved1_key);
  builder_.add_authorization_key(authorization_key);
  builder_.add_application_key(application_key);
  return builder_.Finish();
}

struct KeyDiversificationResponse::Traits {
  using type = KeyDiversificationResponse;
  static auto constexpr Create = CreateKeyDiversificationResponse;
};

::flatbuffers::Offset<KeyDiversificationResponse> CreateKeyDiversificationResponse(::flatbuffers::FlatBufferBuilder &_fbb, const KeyDiversificationResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline KeyDiversificationRequestT::KeyDiversificationRequestT(const KeyDiversificationRequestT &o)
      : token_id((o.token_id) ? new oww::ntag::TagUid(*o.token_id) : nullptr) {
}

inline KeyDiversificationRequestT &KeyDiversificationRequestT::operator=(KeyDiversificationRequestT o) FLATBUFFERS_NOEXCEPT {
  std::swap(token_id, o.token_id);
  return *this;
}

inline KeyDiversificationRequestT *KeyDiversificationRequest::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<KeyDiversificationRequestT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void KeyDiversificationRequest::UnPackTo(KeyDiversificationRequestT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = token_id(); if (_e) _o->token_id = std::unique_ptr<oww::ntag::TagUid>(new oww::ntag::TagUid(*_e)); }
}

inline ::flatbuffers::Offset<KeyDiversificationRequest> KeyDiversificationRequest::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const KeyDiversificationRequestT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKeyDiversificationRequest(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<KeyDiversificationRequest> CreateKeyDiversificationRequest(::flatbuffers::FlatBufferBuilder &_fbb, const KeyDiversificationRequestT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const KeyDiversificationRequestT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _token_id = _o->token_id ? _o->token_id.get() : nullptr;
  return oww::personalization::CreateKeyDiversificationRequest(
      _fbb,
      _token_id);
}

inline KeyDiversificationResponseT::KeyDiversificationResponseT(const KeyDiversificationResponseT &o)
      : application_key((o.application_key) ? new oww::ntag::KeyBytes(*o.application_key) : nullptr),
        authorization_key((o.authorization_key) ? new oww::ntag::KeyBytes(*o.authorization_key) : nullptr),
        reserved1_key((o.reserved1_key) ? new oww::ntag::KeyBytes(*o.reserved1_key) : nullptr),
        reserved2_key((o.reserved2_key) ? new oww::ntag::KeyBytes(*o.reserved2_key) : nullptr) {
}

inline KeyDiversificationResponseT &KeyDiversificationResponseT::operator=(KeyDiversificationResponseT o) FLATBUFFERS_NOEXCEPT {
  std::swap(application_key, o.application_key);
  std::swap(authorization_key, o.authorization_key);
  std::swap(reserved1_key, o.reserved1_key);
  std::swap(reserved2_key, o.reserved2_key);
  return *this;
}

inline KeyDiversificationResponseT *KeyDiversificationResponse::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::make_unique<KeyDiversificationResponseT>();
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void KeyDiversificationResponse::UnPackTo(KeyDiversificationResponseT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = application_key(); if (_e) _o->application_key = std::unique_ptr<oww::ntag::KeyBytes>(new oww::ntag::KeyBytes(*_e)); }
  { auto _e = authorization_key(); if (_e) _o->authorization_key = std::unique_ptr<oww::ntag::KeyBytes>(new oww::ntag::KeyBytes(*_e)); }
  { auto _e = reserved1_key(); if (_e) _o->reserved1_key = std::unique_ptr<oww::ntag::KeyBytes>(new oww::ntag::KeyBytes(*_e)); }
  { auto _e = reserved2_key(); if (_e) _o->reserved2_key = std::unique_ptr<oww::ntag::KeyBytes>(new oww::ntag::KeyBytes(*_e)); }
}

inline ::flatbuffers::Offset<KeyDiversificationResponse> KeyDiversificationResponse::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const KeyDiversificationResponseT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateKeyDiversificationResponse(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<KeyDiversificationResponse> CreateKeyDiversificationResponse(::flatbuffers::FlatBufferBuilder &_fbb, const KeyDiversificationResponseT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const KeyDiversificationResponseT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _application_key = _o->application_key ? _o->application_key.get() : nullptr;
  auto _authorization_key = _o->authorization_key ? _o->authorization_key.get() : nullptr;
  auto _reserved1_key = _o->reserved1_key ? _o->reserved1_key.get() : nullptr;
  auto _reserved2_key = _o->reserved2_key ? _o->reserved2_key.get() : nullptr;
  return oww::personalization::CreateKeyDiversificationResponse(
      _fbb,
      _application_key,
      _authorization_key,
      _reserved1_key,
      _reserved2_key);
}

}  // namespace personalization
}  // namespace oww

#endif  // FLATBUFFERS_GENERATED_PERSONALIZATION_OWW_PERSONALIZATION_H_
